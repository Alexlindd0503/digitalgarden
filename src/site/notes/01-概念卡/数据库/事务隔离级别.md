---
{"dg-publish":true,"permalink":"/01-概念卡/数据库/事务隔离级别/","tags":["事务","隔离级别","并发问题","概念卡","tech/mysql"]}
---

## 1. 核心概念
事务隔离级别定义了一个事务可能受其他并发事务影响的程度，用于平衡**数据一致性**和**并发性能**。SQL 标准定义了 4 个隔离级别。

## 2. 并发问题

### 2.1. 脏读（Dirty Read）
读取到其他事务**未提交**的数据。

```sql
-- 事务 A
BEGIN;
UPDATE users SET age=26 WHERE id=1;
-- 未提交

-- 事务 B
BEGIN;
SELECT age FROM users WHERE id=1;  -- 读到 26（脏读）
COMMIT;

-- 事务 A 回滚
ROLLBACK;  -- age 恢复为 25
```

**问题**: 事务 B 读到的数据是无效的。

### 2.2. 不可重复读（Non-Repeatable Read）
同一事务中，多次读取**同一行**数据结果不同。

```sql
-- 事务 A
BEGIN;
SELECT age FROM users WHERE id=1;  -- 读到 25

-- 事务 B
BEGIN;
UPDATE users SET age=26 WHERE id=1;
COMMIT;

-- 事务 A 再次读取
SELECT age FROM users WHERE id=1;  -- 读到 26（不可重复读）
COMMIT;
```

**问题**: 同一事务内读取结果不一致。

### 2.3. 幻读（Phantom Read）
同一事务中，多次查询**范围数据**结果不同。

```sql
-- 事务 A
BEGIN;
SELECT * FROM users WHERE age > 20;  -- 返回 3 条

-- 事务 B
BEGIN;
INSERT INTO users VALUES (4, '王五', 25);
COMMIT;

-- 事务 A 再次查询
SELECT * FROM users WHERE age > 20;  -- 返回 4 条（幻读）
COMMIT;
```

**问题**: 查询结果集发生变化，出现"幻影"行。

## 3. 四种隔离级别

### 3.1. 对比表
| 隔离级别             | 脏读   | 不可重复读 | 幻读    | 实现方式            |
| ---------------- | ---- | ----- | ----- | --------------- |
| READ UNCOMMITTED | ✅ 可能 | ✅ 可能  | ✅ 可能  | 无锁              |
| READ COMMITTED   | ❌ 不会 | ✅ 可能  | ✅ 可能  | MVCC            |
| REPEATABLE READ  | ❌ 不会 | ❌ 不会  | ⚠️ 部分 | MVCC + Gap Lock |
| SERIALIZABLE     | ❌ 不会 | ❌ 不会  | ❌ 不会  | 锁               |

### 3.2. READ UNCOMMITTED（读未提交）

#### 3.2.1. 特点
- 最低隔离级别
- 读操作不加锁
- 可以读到未提交的数据

#### 3.2.2. 设置
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

#### 3.2.3. 示例
```sql
-- 事务 A
BEGIN;
UPDATE users SET age=26 WHERE id=1;

-- 事务 B（可以读到未提交的数据）
BEGIN;
SELECT age FROM users WHERE id=1;  -- 26（脏读）
COMMIT;

-- 事务 A 回滚
ROLLBACK;
```

**使用场景**: 几乎不使用（数据不一致风险高）

### 3.3. READ COMMITTED（读已提交）

#### 3.3.1. 特点
- 只能读到已提交的数据
- 每次查询创建新的 Read View
- Oracle、PostgreSQL 默认级别

#### 3.3.2. 设置
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 3.3.3. 示例
```sql
-- 事务 A
BEGIN;
SELECT age FROM users WHERE id=1;  -- 25

-- 事务 B
BEGIN;
UPDATE users SET age=26 WHERE id=1;
COMMIT;

-- 事务 A 再次查询（创建新 Read View）
SELECT age FROM users WHERE id=1;  -- 26（不可重复读）
COMMIT;
```

**使用场景**: 
- 对一致性要求不高
- 需要较高并发性能
- 可以接受不可重复读

### 3.4. REPEATABLE READ（可重复读）

#### 3.4.1. 特点
- MySQL InnoDB 默认级别
- 事务内多次读取结果一致
- 使用 MVCC + Gap Lock
- 基本解决幻读（快照读）

#### 3.4.2. 设置
```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

#### 3.4.3. 示例：可重复读
```sql
-- 事务 A
BEGIN;
SELECT age FROM users WHERE id=1;  -- 25（创建 Read View）

-- 事务 B
BEGIN;
UPDATE users SET age=26 WHERE id=1;
COMMIT;

-- 事务 A 再次查询（复用 Read View）
SELECT age FROM users WHERE id=1;  -- 25（可重复读）
COMMIT;
```

#### 3.4.4. 示例：幻读
```sql
-- 快照读：不会幻读
BEGIN;
SELECT * FROM users WHERE age > 20;  -- 3 条
-- 其他事务插入新数据
SELECT * FROM users WHERE age > 20;  -- 仍然 3 条

-- 当前读：可能幻读
SELECT * FROM users WHERE age > 20 FOR UPDATE;  -- 4 条（幻读）
COMMIT;
```

**使用场景**: 
- 大多数业务场景（推荐）
- 需要事务内一致性
- 平衡性能和一致性

### 3.5. SERIALIZABLE（串行化）

#### 3.5.1. 特点
- 最高隔离级别
- 完全串行执行
- 读加共享锁，写加排他锁
- 完全避免并发问题

#### 3.5.2. 设置
```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

#### 3.5.3. 示例
```sql
-- 事务 A
BEGIN;
SELECT * FROM users WHERE age > 20;  -- 加共享锁

-- 事务 B（被阻塞）
BEGIN;
INSERT INTO users VALUES (4, '王五', 25);  -- 等待事务 A 释放锁
-- 等待超时或事务 A 提交

-- 事务 A 提交
COMMIT;

-- 事务 B 继续执行
COMMIT;
```

**使用场景**: 
- 金融交易等对一致性要求极高的场景
- 并发量低的系统
- 可以接受性能损失

## 4. 隔离级别实现

### 4.1. READ COMMITTED 实现
```
每次 SELECT 创建新的 Read View

事务 A:
├─ SELECT ... (创建 Read View 1)
├─ 其他事务提交
└─ SELECT ... (创建 Read View 2) ← 看到新数据
```

### 4.2. REPEATABLE READ 实现
```
第一次 SELECT 创建 Read View，后续复用

事务 A:
├─ SELECT ... (创建 Read View)
├─ 其他事务提交
└─ SELECT ... (复用 Read View) ← 看不到新数据
```

### 4.3. SERIALIZABLE 实现
```
所有 SELECT 自动加 LOCK IN SHARE MODE

事务 A:
└─ SELECT ... (加共享锁，阻塞其他写操作)
```

## 5. 查看和设置

### 5.1. 查看当前隔离级别
```sql
-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 查看会话隔离级别
SELECT @@session.transaction_isolation;
SELECT @@transaction_isolation;

-- MySQL 5.7 及以前版本
SELECT @@tx_isolation;
```

### 5.2. 设置隔离级别
```sql
-- 设置全局隔离级别（影响新连接）
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 设置会话隔离级别（当前连接）
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置下一个事务的隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### 5.3. 配置文件设置
```ini
# my.cnf
[mysqld]
transaction-isolation = REPEATABLE-READ
```

## 6. 性能对比

### 6.1. 并发性能
```
READ UNCOMMITTED  ━━━━━━━━━━ 100%（最高）
READ COMMITTED    ━━━━━━━━━  90%
REPEATABLE READ   ━━━━━━━    70%
SERIALIZABLE      ━━━       30%（最低）
```

### 6.2. 一致性保证
```
READ UNCOMMITTED  ━         10%（最低）
READ COMMITTED    ━━━━      40%
REPEATABLE READ   ━━━━━━━   70%
SERIALIZABLE      ━━━━━━━━━━ 100%（最高）
```

## 7. 实战案例

### 7.1. 案例 1：电商库存扣减
```sql
-- ❌ READ COMMITTED（可能超卖）
BEGIN;
SELECT stock FROM products WHERE id=1;  -- stock=10
-- 其他事务也读到 stock=10
UPDATE products SET stock=stock-1 WHERE id=1;
COMMIT;

-- ✅ REPEATABLE READ + 当前读
BEGIN;
SELECT stock FROM products WHERE id=1 FOR UPDATE;  -- 加锁
UPDATE products SET stock=stock-1 WHERE id=1;
COMMIT;
```

### 7.2. 案例 2：账户转账
```sql
-- ✅ REPEATABLE READ（推荐）
BEGIN;
-- 检查余额
SELECT balance FROM accounts WHERE id=1 FOR UPDATE;  -- 1000

-- 扣款
UPDATE accounts SET balance=balance-100 WHERE id=1;

-- 加款
UPDATE accounts SET balance=balance+100 WHERE id=2;

COMMIT;
```

### 7.3. 案例 3：报表统计
```sql
-- ✅ READ COMMITTED（性能优先）
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

BEGIN;
-- 统计数据（允许读到最新数据）
SELECT COUNT(*), SUM(amount) FROM orders WHERE date=CURDATE();
COMMIT;
```

## 8. 选择建议

### 8.1. 业务场景选择
| 场景 | 推荐级别 | 原因 |
|------|---------|------|
| 一般查询 | REPEATABLE READ | 默认，平衡性能和一致性 |
| 报表统计 | READ COMMITTED | 允许读最新数据，性能好 |
| 库存扣减 | REPEATABLE READ + 锁 | 防止超卖 |
| 金融交易 | SERIALIZABLE | 数据一致性最重要 |
| 日志记录 | READ UNCOMMITTED | 对一致性要求低 |

### 8.2. 性能优化建议
```sql
-- 1. 大部分场景使用默认级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 2. 报表查询降低隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 3. 关键操作使用当前读
SELECT * FROM orders WHERE id=1 FOR UPDATE;

-- 4. 避免长事务
BEGIN;
-- 快速执行
COMMIT;
```

## 9. 常见问题

### 9.1. Q1: 为什么 MySQL 默认是 REPEATABLE READ？
- 历史原因：早期 binlog 使用 Statement 格式
- Statement 格式在 READ COMMITTED 下可能导致主从不一致
- REPEATABLE READ 保证主从数据一致性

### 9.2. Q2: REPEATABLE READ 如何避免幻读？
- 快照读：使用 MVCC，读取历史版本
- 当前读：使用 Next-Key Lock，锁定范围

### 9.3. Q3: 如何选择隔离级别？
```
考虑因素：
1. 业务对一致性的要求
2. 系统并发量
3. 可接受的性能损失
4. 是否有并发冲突

一般建议：使用默认的 REPEATABLE READ
```

## 10. 最佳实践

### 10.1. ✅ 推荐做法
1. 使用默认的 REPEATABLE READ
2. 关键操作使用 FOR UPDATE
3. 及时提交事务
4. 避免在事务中执行耗时操作
5. 根据业务场景调整隔离级别

### 10.2. ❌ 避免做法
1. 滥用 SERIALIZABLE
2. 在事务中执行长时间操作
3. 不了解隔离级别就随意修改
4. 忽略并发问题
5. 不使用索引导致锁范围扩大

## 11. 相关概念
- [[01-概念卡/数据库/MVCC并发控制机制\|MVCC并发控制机制]] - MVCC 实现
- [[01-概念卡/数据库/InnoDB存储引擎原理\|InnoDB存储引擎原理]] - 存储机制
- [[01-概念卡/数据库/MySQL锁机制详解\|MySQL锁机制详解]] - 锁的实现
- [[01-概念卡/数据库/事务ACID特性\|事务ACID特性]] - 事务特性

## 12. 参考资源
- [MySQL 事务隔离级别官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

