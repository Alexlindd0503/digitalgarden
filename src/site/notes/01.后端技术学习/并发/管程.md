---
{"dg-publish":true,"permalink":"/01.后端技术学习/并发/管程/"}
---

- 管程 Monitor，管理共享变量以及对共享变量的操作过程，让他们支持并发
- 管程能够实现信号量，信号量也能实现管程
- java 选择了更容易使用的管程 的 MESA 模型
- MESA 模型
	- 解决**互斥**，将共享变量以及其操作都封装起来了，同时只允许一个线程来操作
		- ![Resource/附件/063c991026a3acf0802e7e4fe124cecf_MD5.png|238](/img/user/Resource/%E9%99%84%E4%BB%B6/063c991026a3acf0802e7e4fe124cecf_MD5.png)
	- 解决**同步**，一个入口队列，同时每个条件变量有对应的等待队列
		- ![Resource/附件/2accb2dd5d5adede99834407afc9fff7_MD5.png|325](/img/user/Resource/%E9%99%84%E4%BB%B6/2accb2dd5d5adede99834407afc9fff7_MD5.png)

- 如何通知相关线程是这几种模型的差异点，**强制约束：同一时刻只有一个线程执行**
	- Hasen 模型：notify 放代码最后，T2 通知完 T1，自己结束，T1 运行，满足约束
	- Hoare 模型：T2 通知完进入阻塞，T1 执行，T1 完唤醒 T2，满足约束
	- MESA 模型：T2 通知后，继续执行，**T1 仅仅从条件变量的等待队列进入入口等待队列**，好处 notify 不需要放代码最后，坏处曾经满足的条件，现在不一定满足，需要再次判断。