---
{"dg-publish":true,"permalink":"/01.后端技术学习/并发/互斥锁/"}
---

### 1. 锁的示意
![锁的示意.png|500](/img/user/Resource/%E9%99%84%E4%BB%B6/%E9%94%81%E7%9A%84%E7%A4%BA%E6%84%8F.png)
### 2. 使用注意事项
- 锁跟资源需要对应上，不能我家的锁，锁别人家的资源
- 受锁的资源与锁的关联关系是N:1
- 不同的锁对受保护资源进行精细化管理，能够提升性能。即**细颗粒锁**
- **使用锁的正确姿势：锁能够覆盖所有受保护资源**

### 3. ❌错误示例
```java
class Account{
    private int balance;
    //转账
    //这边锁的对象是this，锁不到target.balance 所有有问题
    //解决方案： 升级锁Account.class 太重了 会导致所有转账异常
    synchronized void transfer(Account target,int amt){
        if(this.balance > amt){
            this.balance -= amt;
            target.balance += amt;
        }
    }
    // 这边可能会出现死锁
    void transferSafe(Account target,int amt){
        synchronized(this){
            synchronized(target){
                if(this.balance > amt){
                    this.balance -= amt;
                    target.balance += amt;
                }
            }
        }

    }
}
```

### 4. 死锁&解决方案
死锁：两个或多个线程互相持有对方需要的资源，导致所有线程都无法继续执行的情况。
以下4个条件都发生时才会出现死锁，只要破坏其中一个，就能避免死锁。
1. 互斥。共享资源X和Y只能被一个线程占用（不好破坏，锁就是用来互斥的）❌
2. 占用且等待，线程T1已经取得共享资源X，在等待Y的时候，不释放X
	1. **解决方案：<span class="cloze-span">一次性申请**</span>
3. 不可抢占，其他线程不能强行抢占线程T1占用的资源 
	1. **解决方案：<span class="cloze-span">占用资源的线程申请不到其他资源，则主动释放它占用的资源**</span>
4. 循环等待，线程T1等待T2占用的资源，线程T2等待线程T1占用的资源
	1. **解决方案：<span class="cloze-span">按照顺序执行，例如Account的Id进行执行</span>**

### 5. 示例代码

```java
//Allocator 需要单例 进行资源的统一管理
class Allocator {
    private List<Object> als=new ArrayList<>();
    //一次性申请所有资源
    synchronized boolean apply(Object from,Object to){
        if(als.contains(from)||als.contains(to)){
                return false;
        } else{
            als.add(from);
            als.add(to);
        }
        return true;
    }
    synchronized void free(Object from,Object to){
        als.remove(from);
        als.remove(to);
    }

}
class Account
{
    private Allocator actr;
    private int balance;
    void transfer(Account target,int amt){
        //一次性申请转入、转出账户 直到成功
        while(!actr.apply(this,target))
        ;
        try{
            synchronized(this){
                synchronized(target){
                    if(this.balance > amt){
                        this.balance -=amt;
                        target.balance +=amt;
                    }
                }
            }
        }
        finally{
            actr.free(this,target);
        }
    }
}
```
第 26 行 `while(!actr.apply(this,target))` 会进行死循环等待，浪费 CPU。
可以利用[[01.后端技术学习/并发/等待-通知机制\|01.后端技术学习/并发/等待-通知机制]]进行优化。