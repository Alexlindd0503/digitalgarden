---
{"dg-publish":true,"permalink":"/100.Map/00.并发学习/","tags":["gardenEntry"]}
---

#地图

- 万恶之源，多线程的 Bug 来源
	- [[01.后端技术学习/并发/原子性、有序性、可见性\|原子性、有序性、可见性]]，这都是硬件带来的软件问题，本质是好的，提升性能的
	- 在硬件带来的问题同时，看看 Java 是如何靠软件解决这些问题的
		- Java 规定了内存模型 [[01.后端技术学习/并发/JAVA的内存模型\|JAVA的内存模型]]，JVM 内存与主内存如何交互，以及多线程下如何交互
		- 规定了 [[01.后端技术学习/并发/Happens-before\|Happens-before]] 原则
		- 以上规定解决了**有序性与可见性**
		- [[01.后端技术学习/并发/互斥锁\|互斥锁]]，解决了**原子性**
		- 锁使用的好不好，决定了代码的性能好不好，利用[[01.后端技术学习/并发/等待-通知机制\|等待-通知机制]]，可以节省 CPU 空转
	- 然而 Java 提供了相应的解决方案，可实际使用中仍然有其他问题
		- [[01.后端技术学习/并发/安全性、活跃性和性能问题\|安全性、活跃性和性能问题]]
	- 解决并发的万能
		- [[01.后端技术学习/并发/管程\|管程]]
	- 线程相关知识
		- [[01.后端技术学习/并发/Java线程\|Java线程]]：包含线程设置相关
		- [[01.后端技术学习/并发/生产级别 Tomcat 配置推荐\|生产级别 Tomcat 配置推荐]]
- Java 并发工具类
	- [[01.后端技术学习/并发/synchronized&wait&notify\|synchronized&wait&notify]]
		- 缺点：获取不到对应锁，会一直休眠，开发者无法控制
		- ```java
		  synchronized(this){
        //此处如果获取不到，会进行休眠，不释放this的锁
         synchronized(that){
         }
    }
		  ```
	- 提供了 [[01.后端技术学习/并发/Lock 与 Condition 机制\|Lock 与 Condition 机制]]，方便开发者自行控制
	- 基于 Lock 与 Condition 有如下细粒度的锁
		- [[01.后端技术学习/并发/Semaphore 信号量\|Semaphore 信号量]] ：可以控制 N 个线程访问同一资源，传统锁只能控制一个线程对资源访问控制
		- [[01.后端技术学习/并发/ReadWriteLock\|ReadWriteLock]] 读写分离的体现