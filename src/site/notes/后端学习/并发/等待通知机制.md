---
{"dg-publish":true,"permalink":"/后端学习/并发/等待通知机制/"}
---

#线程通信
一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。

Java 多线程的等待/通知机制是基于`Object`类的`wait()`方法和`notify()`, `notifyAll()`方法来实现的。

等待/通知机制，是指一个线程 A 调用了对象 O 的 wait()方法进入等待状态，而另一个线程 B 调用了对象 O 的 notify()或者 notifyAll()方法，线程 A 收到通知后从对象 O 的 wait()方法返回，进而执行后续操作。
[[资料库/附件/b9457196aa86c05dbae2eef9c96f936f_MD5.png|Open: d3d6c2a60839f585976c0df5487d5768.png]]
![资料库/附件/b9457196aa86c05dbae2eef9c96f936f_MD5.png](/img/user/%E8%B5%84%E6%96%99%E5%BA%93/%E9%99%84%E4%BB%B6/b9457196aa86c05dbae2eef9c96f936f_MD5.png)

```java
public class TestSync {
    public static void main(String[] args) {
        // 定义一个锁对象
	 Object lock = new Object();
        List<String>  list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                for (int i = 1; i <= 10; i++) {
                    list.add("abc");
                    System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (list.size() == 5)
                        lock.notify();// 唤醒B线程
                }
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    if (list.size() != 5) {
                        try {
                        	// 此时释放了synchronized锁了吗
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println("线程B收到通知，开始执行自己的业务...");
                }
            }
        });
        // 需要先启动线程B
        threadB.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 再启动线程A
        threadA.start();
    }
}
```

**等待方**遵循如下原则。

1. 获取对象的锁。
2. 如果条件不满足，那么调用对象的 wait()方法，被通知后仍要检查条件。
3. 条件满足则执行对应的逻辑。

对应的伪代码如下。

```java
synchronized(对象) {
  while(条件不满足) {
    对象.wait();
  }
   满足条件对应的处理逻辑
}
```

**通知方规范**

通知方遵循如下原则。

1. 获得对象的锁。
2. 改变条件。
3. 通知所有等待在对象上的线程。

对应的伪代码如下。

```java
synchronized(对象) {
  改变条件
  对象.notifyAll();
}
```
